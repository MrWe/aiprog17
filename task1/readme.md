# A-Star Algorithm
By Agnete Djupvik and Erik Wiker

## How to run
Requires installation of [Python 3.x](https://www.python.org/download/releases/3.0/) and [Tkinter](http://www.tkdocs.com/tutorial/install.html)
```
> python3 gui.py
```

## Heuristic function
The heuristic function used to solve the puzzle consists of two parts, described below.

##### Manhattan Distance
For two coordinates ```x = (a, b)``` and ```y = (c, d)```, the Manhattan distance between ```x``` and ```y``` is ```|a - c| + |b - d|```. This heuristic decides how many steps are in the shortest path from ```x``` to ```y```, given that moves can only be made along the X and Y axes, not in diagonal.
As this mode of orientation is the case in our Rush Hour world, and even a simpler mode which in fact only allows a block to move along _one_ axis, this simple heuristic will suffice.

##### Path blockage
As development on the code progressed, and in the nature of having a board consisting of 6x6 tiles, a large amount of states will return the same Manhattan distance. Thus, another heuristic also weighs in; the algorithm wants to minimize the number of cars which block the goal, meaning that they are placed in a position between the car and the goal.

## Successor states
A thorough description of the procedure used to generate successor states when expanding a node.
A central part of the task was determining a sensible form of keeping track of the state and possible permutations. In the algorithm at hand, a _node_ is an object containing the _entire_ board state. This includes keeping track all cars and their positions on the current board, as well as ```g```, ```h``` and thus ```f``` values.

Upon the generation of a current node's neighbors, all possible permutations of all cars on the board are considered (their movements, however, are restricted to moving _one_ step in their given orientation). For each valid move of a single car, a new neighbor state is generated (as long as it doesn't already exist) with that one move as the only change.

## Algorithm performance
A comparison of A*â€™s performance to that of both depth-first and breadth-first search when applied to each of the 4 puzzles above.

| Search Method | Easy-3 | Medium-1 | Hard-3 | Expert-2 |
| --- | --- |
| Breadth-first | Hei | Hei | Hei | Hei |
| Depth-first | Hei | Hei | Hei | Hei |
| Best-first | 61, 17 | 528, 25 | 634, 34 | 4472, 76 |

The comparison of A* to depth- and breadth-first search should consist of two factors:
- the total number of nodes generated by the search tree,
- the number of moves in the first solution that the method finds. All of this should be expressed in the exact same format as shown in Table 2
