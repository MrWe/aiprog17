# A-Star Algorithm
By Agnete Djupvik and Erik Wiker

## How to run
Requires installation of [Python 3.x](https://www.python.org/download/releases/3.0/) and [Tkinter](http://www.tkdocs.com/tutorial/install.html)
```
> python3 gui.py
```

## Heuristic function
The heuristic function used to solve the puzzle consists of two parts, described below.

##### Manhattan Distance
For two coordinates ```x = (a, b)``` and ```y = (c, d)```, the Manhattan distance between ```x``` and ```y``` is ```|a - c| + |b - d|```. This heuristic decides how many steps are in the shortest path from ```x``` to ```y```, given that moves can only be made along the X and Y axes, not in diagonal.
As this mode of orientation is the case in our Rush Hour world, and even a simpler mode which in fact only allows a block to move along _one_ axis, this simple heuristic will suffice.

##### Path blockage
As development on the code progressed, and in the nature of having a board consisting of 6x6 tiles, a large amount of states will return the same Manhattan distance. Thus, another heuristic also weighs in; the algorithm wants to minimize the number of cars which block the goal, meaning that they are placed in a position between the car and the goal.

## Successor states
A thorough description of the procedure used to generate successor states when expanding a node.
A central part of the task was determining a sensible form of keeping track of the state and possible permutations. In the algorithm at hand, a _node_ is an object containing the _entire_ board state. This includes keeping track all cars and their positions on the current board, as well as ```g```, ```h``` and thus ```f``` values.

Upon the generation of a current node's neighbors, all possible permutations of all cars on the board are considered (their movements, however, are restricted to moving _one_ step in their given orientation). For each valid move of a single car, a new neighbor state is generated (as long as it doesn't already exist) with that one move as the only change.

## Algorithm performance
The following table displays a comparison of A*â€™s performance to that of both depth-first and breadth-first search when applied to each of the 4 puzzles above.
The two factors for each cell indicates the following:
- The total number of nodes generated by the search tree,
- The number of moves in the first solution that the method finds

| Search Method | Easy-3 | Medium-1 | Hard-3 | Expert-2 |
| --- | --- |
| Depth-first | 34, 18 | 422, 49 | 605, 126 | 3086, 124 |
| Breadth-first | 94, 17 | 774, 25 | 1708, 34 | 10194, 74 |
| Best-first | 61, 17 | 528, 25 | 634, 34 | 4472, 74 |

As we can see from this table, all of the algorithms have areas where they perform well.
On the _easy_ board, DFS performs quicker, and finds an _almost_ optimal solution. However, on harder boards, it immediately decides on the first solution and it becomes evident that the path it decides on virtually never can be accepted as it is much longer than the optimal path.
On the other hand, we see that BFS _will_ find the optimal solution, but with far many more expanded nodes. As the the search tree grows, the number of nodes expanded grows much too rapidly for it to perform efficiently. Here, we can see that the A* _best first_ search far outperforms the other algorithms as it is generally quick enough _and_ guarantees an optimal solution.
